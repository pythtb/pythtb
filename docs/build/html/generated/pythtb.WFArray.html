
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>pythtb.WFArray &#8212; PythTB Docs</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=7f41d439"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=cbcfbdad"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = "div.nbinput"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'generated/pythtb.WFArray';</script>
    <script defer="defer" src="../_static/custom-icons.js?v=7518156e"></script>
    <script src="https://unpkg.com/thebe@latest/lib/index.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="pythtb.W90" href="pythtb.W90.html" />
    <link rel="prev" title="pythtb.TBModel" href="pythtb.TBModel.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">PythTB Docs</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../about.html">
    About
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../install.html">
    Install
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="../usage.html">
    Usage
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../examples.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../CHANGELOG.html">
    Changelog
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../formalism.html">
    Formalism
  </a>
</li>

            <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-nav-more-links">
                    More
                </button>
                <ul id="pst-nav-more-links" class="dropdown-menu">
                    
<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../resources.html">
    Resources
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../citation.html">
    Citation
  </a>
</li>

                </ul>
            </li>
            
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
      
        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script></div>
      
        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/treycole/pythtb" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/pythtb/" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-custom fa-pypi fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../about.html">
    About
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../install.html">
    Install
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="../usage.html">
    Usage
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../examples.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../CHANGELOG.html">
    Changelog
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../formalism.html">
    Formalism
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../resources.html">
    Resources
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../citation.html">
    Citation
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script></div>
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/treycole/pythtb" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/pythtb/" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-custom fa-pypi fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><p aria-level="2" class="caption" role="heading"><span class="caption-text">PythTB Classes</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="pythtb.TBModel.html">pythtb.TBModel</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">pythtb.WFArray</a></li>
<li class="toctree-l1"><a class="reference internal" href="pythtb.W90.html">pythtb.W90</a></li>
<li class="toctree-l1"><a class="reference internal" href="pythtb.Wannier.html">pythtb.Wannier</a></li>
<li class="toctree-l1"><a class="reference internal" href="pythtb.Bloch.html">pythtb.Bloch</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">PythTB Plotting</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="pythtb.plotting.plot_bands.html">pythtb.plotting.plot_bands</a></li>
<li class="toctree-l1"><a class="reference internal" href="pythtb.plotting.plot_tb_model.html">pythtb.plotting.plot_tb_model</a></li>
<li class="toctree-l1"><a class="reference internal" href="pythtb.plotting.plot_tb_model_3d.html">pythtb.plotting.plot_tb_model_3d</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">PythTB Models</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="pythtb.models.ssh.html">pythtb.models.ssh</a></li>
<li class="toctree-l1"><a class="reference internal" href="pythtb.models.checkerboard.html">pythtb.models.checkerboard</a></li>
<li class="toctree-l1"><a class="reference internal" href="pythtb.models.graphene.html">pythtb.models.graphene</a></li>
<li class="toctree-l1"><a class="reference internal" href="pythtb.models.haldane.html">pythtb.models.haldane</a></li>
<li class="toctree-l1"><a class="reference internal" href="pythtb.models.kane_mele.html">pythtb.models.kane_mele</a></li>
<li class="toctree-l1"><a class="reference internal" href="pythtb.models.fu_kane_mele.html">pythtb.models.fu_kane_mele</a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../usage.html" class="nav-link">Usage</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">pythtb.WFArray</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="pythtb-wfarray">
<h1>pythtb.WFArray<a class="headerlink" href="#pythtb-wfarray" title="Link to this heading">#</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="pythtb.WFArray">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pythtb.</span></span><span class="sig-name descname"><span class="pre">WFArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nstates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray" title="Link to this definition">#</a></dt>
<dd><p>This class is used to store and manipulate an array of
wavefunctions of a tight-binding model
<a class="reference internal" href="pythtb.TBModel.html#pythtb.TBModel" title="pythtb.TBModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">pythtb.TBModel</span></code></a> on a regular or non-regular grid.
These could be the Bloch energy eigenstates of the
model, but could also be a subset of Bloch bands,
a set of hybrid Wannier functions for a ribbon or slab,
or any other set of wavefunctions that are expressed in terms
of the underlying basis orbitals. It provides methods that can
be used to calculate Berry phases, Berry curvatures,
first Chern numbers, etc.</p>
<p>The wavevectors stored in <em>WFArray</em> are typically Hamiltonian
eigenstates (e.g., Bloch functions for k-space arrays),
with the <em>state</em> index running over all bands. However, a
<em>WFArray</em> object can also be used for other purposes, such
as to store only a restricted set of Bloch states (e.g.,
just the occupied ones); a set of modified Bloch states
(e.g., premultiplied by a position, velocity, or Hamiltonian
operator); or for hybrid Wannier functions (i.e., eigenstates
of a position operator in a nonperiodic direction).</p>
<p><em>Regular k-space grid</em>:
If the grid is a regular k-mesh (no parametric dimensions),
a single call to the function <a class="reference internal" href="#pythtb.WFArray.solve_on_grid" title="pythtb.WFArray.solve_on_grid"><code class="xref py py-func docutils literal notranslate"><span class="pre">pythtb.WFArray.solve_on_grid()</span></code></a>
will both construct a k-mesh that uniformly covers the Brillouin zone,
and populate it with the energy eigenvectors computed on this grid.
This function will ensure that the last point along each k-dimension is
the same Bloch function as the first one multiplied by a phase factor to
ensure the periodic boundary conditions are satisfied (see notes below).</p>
<p><em>Parametric or irregular k-space grid grid</em>:
An irregular grid of points, or a grid that includes also
one or more parametric dimensions, can be populated manually
using the <code class="docutils literal notranslate"><span class="pre">[]</span></code> operator (see example below). The wavefunctions
above are expected to be in the format <cite>evec[state, orbital]</cite>
(or <cite>evec[state, orbital, spin]</cite> for the spinfull calculation).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="pythtb.TBModel.html#pythtb.TBModel" title="pythtb.TBModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">pythtb.TBModel</span></code></a>) – A <a class="reference internal" href="pythtb.TBModel.html#pythtb.TBModel" title="pythtb.TBModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">pythtb.TBModel</span></code></a> representing
the tight-binding model associated with this array of eigenvectors.</p></li>
<li><p><strong>mesh_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.13)"><em>tuple</em></a>) – A list or tuple specifying the size of the mesh of points
in the order of reciprocal-space and/or parametric directions.</p></li>
<li><p><strong>nstates</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Optional parameter specifying the number of states
packed into the <em>WFArray</em> at each point on the mesh. Defaults
to all states (i.e., <cite>norb*nspin</cite>).</p></li>
<li><p><strong>mesh</strong> (<em>Mesh</em>)</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="../examples_ipynb/haldane_bp.html#haldane-bp-nb"><span class="std std-ref">Haldane model Berry phases and curvatures</span></a></dt><dd><p>For an example of using WFArray on a regular grid of points in k-space.</p>
</dd>
<dt><a class="reference internal" href="../examples_ipynb/graphene_cone.html#cone-nb"><span class="std std-ref">Berry phase around graphene’s Dirac cone</span></a></dt><dd><p>For an example of using WFArray on a non-regular grid of points in k-space.</p>
</dd>
<dt><a class="reference internal" href="../examples_ipynb/3site_cycle.html#site-cycle-nb"><span class="std std-ref">1D cycle of 1D tight-binding model</span></a></dt><dd><p>For an example of using <cite>WFArray</cite> on a non-regular grid of points in parameter space. This example shows how one of the directions of <em>WFArray</em> object need not be a k-vector direction, but can instead be a Hamiltonian parameter <span class="math notranslate nohighlight">\(\lambda\)</span>. See also discussion after equation 4.1 in <a class="reference internal" href="../formalism.html#formalism"><span class="std std-ref">Formalism</span></a>.</p>
</dd>
<dt><a class="reference internal" href="../examples_ipynb/slab_hwf.html#cubic-slab-hwf-nb"><span class="std std-ref">Hybrid Wannier functions in slab</span></a></dt><dd><p>For an example of using <cite>WFArray</cite> to store hybrid Wannier functions.</p>
</dd>
</dl>
<p><a class="reference internal" href="pythtb.TBModel.html#pythtb.TBModel.solve_ham" title="pythtb.TBModel.solve_ham"><code class="xref py py-func docutils literal notranslate"><span class="pre">pythtb.TBModel.solve_ham()</span></code></a>, <a class="reference internal" href="../formalism.html#formalism"><span class="std std-ref">Formalism</span></a></p>
</div>
<p class="rubric">Notes</p>
<p>When using <a class="reference internal" href="#pythtb.WFArray.solve_on_grid" title="pythtb.WFArray.solve_on_grid"><code class="xref py py-func docutils literal notranslate"><span class="pre">pythtb.WFArray.solve_on_grid()</span></code></a> the last wavefunction along each mesh dimension
is stored according the the boundary conditions</p>
<div class="math notranslate nohighlight">
\[u_{n, \mathbf{k} + \mathbf{G}}(\mathbf{r}) = e^{-i \mathbf{G} \cdot \mathbf{r}} u_{n, \mathbf{k}}(\mathbf{r})\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{G}\)</span> is a reciprocal lattice vector and <span class="math notranslate nohighlight">\(\mathbf{r}\)</span> is the position vector.
See section 4.4 in <a class="reference download internal" download="" href="../_downloads/e39c23ce476d399b268efa520e7a9091/pythtb-formalism.pdf"><code class="xref download docutils literal notranslate"><span class="pre">notes</span> <span class="pre">on</span> <span class="pre">tight-binding</span> <span class="pre">formalism</span></code></a> for more details.</p>
<p>If WFArray is used for closed paths, either in a
reciprocal-space or parametric direction, then one needs to
include both the starting and ending eigenfunctions even though
they are physically equivalent. If the array dimension in
question is a k-vector direction and the path traverses the
Brillouin zone in a primitive reciprocal-lattice direction,
<a class="reference internal" href="#pythtb.WFArray.impose_pbc" title="pythtb.WFArray.impose_pbc"><code class="xref py py-func docutils literal notranslate"><span class="pre">pythtb.WFArray.impose_pbc()</span></code></a> can be used to associate
the starting and ending points with each other. If it is a
non-winding loop in k-space or a loop in parameter space,
then <a class="reference internal" href="#pythtb.WFArray.impose_loop" title="pythtb.WFArray.impose_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">pythtb.WFArray.impose_loop()</span></code></a> can be used instead.</p>
<p class="rubric">Examples</p>
<p>Construct <cite>WFArray</cite> capable of storing an 11x21 array of
wavefunctions</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wf</span> <span class="o">=</span> <span class="n">WFArray</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">21</span><span class="p">])</span>
</pre></div>
</div>
<p>Populate this <cite>WFArray</cite> with regular grid of points in
Brillouin zone</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wf</span><span class="o">.</span><span class="n">solve_on_grid</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
</pre></div>
</div>
<p>Compute set of eigenvectors at one k-point</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">eval</span><span class="p">,</span> <span class="n">evec</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">solve_one</span><span class="p">([</span><span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">],</span> <span class="n">eig_vectors</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Store it manually into a specified location in the array</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wf</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">evec</span>
</pre></div>
</div>
<p>To access the eigenvectors from the same position</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wf</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pythtb.WFArray.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nstates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray.__init__" title="Link to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="pythtb.TBModel.html#pythtb.TBModel" title="pythtb.tb_model.TBModel"><em>TBModel</em></a>)</p></li>
<li><p><strong>mesh</strong> (<em>Mesh</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<p class="rubric">Methods</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__delattr__</span></code>(name, /)</p></td>
<td><p>Implement delattr(self, name).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__dir__</span></code>()</p></td>
<td><p>Default dir() implementation.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__eq__</span></code>(value, /)</p></td>
<td><p>Return self==value.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__format__</span></code>(format_spec, /)</p></td>
<td><p>Default object formatter.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__ge__</span></code>(value, /)</p></td>
<td><p>Return self&gt;=value.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__getattribute__</span></code>(name, /)</p></td>
<td><p>Return getattr(self, name).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__getitem__</span></code>(key)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__getstate__</span></code>()</p></td>
<td><p>Helper for pickle.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__gt__</span></code>(value, /)</p></td>
<td><p>Return self&gt;value.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__hash__</span></code>()</p></td>
<td><p>Return hash(self).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pythtb.WFArray.__init__" title="pythtb.WFArray.__init__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__init__</span></code></a>(model, mesh[, nstates])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__init_subclass__</span></code></p></td>
<td><p>This method is called when a class is subclassed.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__le__</span></code>(value, /)</p></td>
<td><p>Return self&lt;=value.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__lt__</span></code>(value, /)</p></td>
<td><p>Return self&lt;value.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__ne__</span></code>(value, /)</p></td>
<td><p>Return self!=value.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__new__</span></code>(*args, **kwargs)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__reduce__</span></code>()</p></td>
<td><p>Helper for pickle.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__reduce_ex__</span></code>(protocol, /)</p></td>
<td><p>Helper for pickle.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__repr__</span></code>()</p></td>
<td><p>Return repr(self).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__setattr__</span></code>(name, value, /)</p></td>
<td><p>Implement setattr(self, name, value).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__setitem__</span></code>(key, value)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__sizeof__</span></code>()</p></td>
<td><p>Size of object in memory, in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__str__</span></code>()</p></td>
<td><p>Return str(self).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__subclasshook__</span></code></p></td>
<td><p>Abstract classes can override this to customize issubclass().</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">_apply_phase</span></code>([inverse])</p></td>
<td><p>Change between cell periodic and Bloch wfs by multiplying exp(pm i k .</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">_check_key</span></code>(key)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pythtb.WFArray.berry_flux" title="pythtb.WFArray.berry_flux"><code class="xref py py-obj docutils literal notranslate"><span class="pre">berry_flux</span></code></a>([state_idx, plane, abelian])</p></td>
<td><p>Berry flux tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pythtb.WFArray.berry_loop" title="pythtb.WFArray.berry_loop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">berry_loop</span></code></a>(wfs_loop[, evals])</p></td>
<td><p>Berry phase along a one-dimensional loop of wavefunctions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pythtb.WFArray.berry_phase" title="pythtb.WFArray.berry_phase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">berry_phase</span></code></a>([occ, dir, contin, berry_evals])</p></td>
<td><p>Berry phase along a given array direction.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pythtb.WFArray.chern_num" title="pythtb.WFArray.chern_num"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chern_num</span></code></a>([plane, state_idx])</p></td>
<td><p>Computes the Chern number in the specified plane.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pythtb.WFArray.choose_states" title="pythtb.WFArray.choose_states"><code class="xref py py-obj docutils literal notranslate"><span class="pre">choose_states</span></code></a>(subset)</p></td>
<td><p>Create a new <em>WFArray</em> object containing a subset of the states in the original one.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pythtb.WFArray.empty_like" title="pythtb.WFArray.empty_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty_like</span></code></a>([nstates])</p></td>
<td><p>Create a new empty <em>WFArray</em> object based on the original.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pythtb.WFArray.get_bloch_states" title="pythtb.WFArray.get_bloch_states"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_bloch_states</span></code></a>([flatten_spin])</p></td>
<td><p>Returns Bloch and cell-periodic states from the WFArray.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pythtb.WFArray.get_links" title="pythtb.WFArray.get_links"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_links</span></code></a>([state_idx, dirs])</p></td>
<td><p>Compute the overlap links (unitary matrices) for the wavefunctions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pythtb.WFArray.get_projectors" title="pythtb.WFArray.get_projectors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_projectors</span></code></a>([return_Q])</p></td>
<td><p>Returns the band projectors associated with the states in the WFArray.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pythtb.WFArray.get_states" title="pythtb.WFArray.get_states"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_states</span></code></a>([flatten_spin])</p></td>
<td><p>Returns states stored in the WFArray.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pythtb.WFArray.impose_loop" title="pythtb.WFArray.impose_loop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">impose_loop</span></code></a>(mesh_dir)</p></td>
<td><p>Impose a loop condition along a given mesh direction.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pythtb.WFArray.impose_pbc" title="pythtb.WFArray.impose_pbc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">impose_pbc</span></code></a>(mesh_dir, k_dir)</p></td>
<td><p>Impose periodic boundary conditions on the WFArray.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pythtb.WFArray.position_expectation" title="pythtb.WFArray.position_expectation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">position_expectation</span></code></a>(k_idx, occ, dir)</p></td>
<td><p>Position expectation value for a given k-point and set of states.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pythtb.WFArray.position_hwf" title="pythtb.WFArray.position_hwf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">position_hwf</span></code></a>(k_idx, occ, dir[, hwf_evec, basis])</p></td>
<td><p>Eigenvalues and eigenvectors of the position operator in a given basis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pythtb.WFArray.position_matrix" title="pythtb.WFArray.position_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">position_matrix</span></code></a>(k_idx, occ, dir)</p></td>
<td><p>Position matrix for a given k-point and set of states.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pythtb.WFArray.solve_k_mesh" title="pythtb.WFArray.solve_k_mesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_k_mesh</span></code></a>([lambda_idx, auto_detect_pbc])</p></td>
<td><p>Solve the Hamiltonian on the k-mesh for a given parameter slice.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pythtb.WFArray.solve_on_grid" title="pythtb.WFArray.solve_on_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_on_grid</span></code></a>([start_k])</p></td>
<td><p>Solve a tight-binding model on a regular mesh of k-points.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pythtb.WFArray.solve_on_one_point" title="pythtb.WFArray.solve_on_one_point"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_on_one_point</span></code></a>(kpt, mesh_indices)</p></td>
<td><p>Solve a tight-binding model on a single k-point.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pythtb.WFArray.solve_on_path" title="pythtb.WFArray.solve_on_path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_on_path</span></code></a>(k_arr)</p></td>
<td><p>Solve the model along a 1D parameter path (e.g., k-points).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pythtb.WFArray.wilson_loop" title="pythtb.WFArray.wilson_loop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wilson_loop</span></code></a>(wfs_loop[, evals])</p></td>
<td><p>Wilson loop unitary matrix</p></td>
</tr>
</tbody>
</table>
</div>
<p class="rubric">Attributes</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__annotations__</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__dict__</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__doc__</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__module__</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__weakref__</span></code></p></td>
<td><p>list of weak references to the object</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pythtb.WFArray.dim_mesh" title="pythtb.WFArray.dim_mesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim_mesh</span></code></a></p></td>
<td><p>The number of dimensions of the <em>WFArray</em> object.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pythtb.WFArray.energies" title="pythtb.WFArray.energies"><code class="xref py py-obj docutils literal notranslate"><span class="pre">energies</span></code></a></p></td>
<td><p>Returns the energies of the states stored in the <em>WFArray</em>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pythtb.WFArray.flat_k_mesh" title="pythtb.WFArray.flat_k_mesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flat_k_mesh</span></code></a></p></td>
<td><p>Returns a flattened version of the k-mesh used in the <em>WFArray</em>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pythtb.WFArray.k_mesh" title="pythtb.WFArray.k_mesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">k_mesh</span></code></a></p></td>
<td><p>Returns the KMesh object associated with the <em>WFArray</em>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pythtb.WFArray.loop_axes" title="pythtb.WFArray.loop_axes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">loop_axes</span></code></a></p></td>
<td><p>The axes along which loops are imposed.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pythtb.WFArray.mesh_size" title="pythtb.WFArray.mesh_size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mesh_size</span></code></a></p></td>
<td><p>The mesh dimensions of the <em>WFArray</em> object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pythtb.WFArray.model" title="pythtb.WFArray.model"><code class="xref py py-obj docutils literal notranslate"><span class="pre">model</span></code></a></p></td>
<td><p>The underlying TBModel object associated with the <em>WFArray</em>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pythtb.WFArray.norb" title="pythtb.WFArray.norb"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norb</span></code></a></p></td>
<td><p>The number of orbitals stored in the <em>WFArray</em> object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pythtb.WFArray.nspin" title="pythtb.WFArray.nspin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nspin</span></code></a></p></td>
<td><p>The number of spin components stored in the <em>WFArray</em> object.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pythtb.WFArray.nstates" title="pythtb.WFArray.nstates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nstates</span></code></a></p></td>
<td><p>The number of states (or bands) stored in the <em>WFArray</em> object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pythtb.WFArray.param_path" title="pythtb.WFArray.param_path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">param_path</span></code></a></p></td>
<td><p>The parameter path (e.g., k-points) along which the model was solved.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pythtb.WFArray.pbc_axes" title="pythtb.WFArray.pbc_axes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pbc_axes</span></code></a></p></td>
<td><p>The axes along which periodic boundary conditions are imposed.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pythtb.WFArray.shape" title="pythtb.WFArray.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></p></td>
<td><p>The shape of the wavefunction array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pythtb.WFArray.wfs" title="pythtb.WFArray.wfs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wfs</span></code></a></p></td>
<td><p>The wavefunctions stored in the <em>WFArray</em> object.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="pythtb.WFArray.wfs">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">wfs</span></span><a class="headerlink" href="#pythtb.WFArray.wfs" title="Link to this definition">#</a></dt>
<dd><p>The wavefunctions stored in the <em>WFArray</em> object.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pythtb.WFArray.shape">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#pythtb.WFArray.shape" title="Link to this definition">#</a></dt>
<dd><p>The shape of the wavefunction array.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pythtb.WFArray.mesh_size">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mesh_size</span></span><a class="headerlink" href="#pythtb.WFArray.mesh_size" title="Link to this definition">#</a></dt>
<dd><p>The mesh dimensions of the <em>WFArray</em> object.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pythtb.WFArray.dim_mesh">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dim_mesh</span></span><a class="headerlink" href="#pythtb.WFArray.dim_mesh" title="Link to this definition">#</a></dt>
<dd><p>The number of dimensions of the <em>WFArray</em> object.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pythtb.WFArray.pbc_axes">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pbc_axes</span></span><a class="headerlink" href="#pythtb.WFArray.pbc_axes" title="Link to this definition">#</a></dt>
<dd><p>The axes along which periodic boundary conditions are imposed.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pythtb.WFArray.loop_axes">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loop_axes</span></span><a class="headerlink" href="#pythtb.WFArray.loop_axes" title="Link to this definition">#</a></dt>
<dd><p>The axes along which loops are imposed.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pythtb.WFArray.nstates">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nstates</span></span><a class="headerlink" href="#pythtb.WFArray.nstates" title="Link to this definition">#</a></dt>
<dd><p>The number of states (or bands) stored in the <em>WFArray</em> object.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pythtb.WFArray.nspin">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nspin</span></span><a class="headerlink" href="#pythtb.WFArray.nspin" title="Link to this definition">#</a></dt>
<dd><p>The number of spin components stored in the <em>WFArray</em> object.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pythtb.WFArray.norb">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">norb</span></span><a class="headerlink" href="#pythtb.WFArray.norb" title="Link to this definition">#</a></dt>
<dd><p>The number of orbitals stored in the <em>WFArray</em> object.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pythtb.WFArray.model">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">model</span></span><a class="headerlink" href="#pythtb.WFArray.model" title="Link to this definition">#</a></dt>
<dd><p>The underlying TBModel object associated with the <em>WFArray</em>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pythtb.WFArray.param_path">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">param_path</span></span><a class="headerlink" href="#pythtb.WFArray.param_path" title="Link to this definition">#</a></dt>
<dd><p>The parameter path (e.g., k-points) along which the model was solved.
This is only set if the model was solved along a path using <cite>solve_on_path</cite>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pythtb.WFArray.flat_k_mesh">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">flat_k_mesh</span></span><a class="headerlink" href="#pythtb.WFArray.flat_k_mesh" title="Link to this definition">#</a></dt>
<dd><p>Returns a flattened version of the k-mesh used in the <em>WFArray</em>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pythtb.WFArray.k_mesh">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">k_mesh</span></span><a class="headerlink" href="#pythtb.WFArray.k_mesh" title="Link to this definition">#</a></dt>
<dd><p>Returns the KMesh object associated with the <em>WFArray</em>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pythtb.WFArray.energies">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">energies</span></span><a class="headerlink" href="#pythtb.WFArray.energies" title="Link to this definition">#</a></dt>
<dd><p>Returns the energies of the states stored in the <em>WFArray</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pythtb.WFArray.get_states">
<span class="sig-name descname"><span class="pre">get_states</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">flatten_spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray.get_states"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray.get_states" title="Link to this definition">#</a></dt>
<dd><p>Returns states stored in the WFArray.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.0.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>flatten_spin</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, the spin and orbital indices are flattened into a single index and
the shape of the returned states will be [nk1, …, nkd, [n_lambda,] n_state, n_orb * n_spin].
If False, the original shape is preserved, [nk1, …, nkd, [n_lambda,] n_state, n_orb, n_spin].</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>states</strong> – The wavefunctions stored in the WFArray.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pythtb.WFArray.get_bloch_states">
<span class="sig-name descname"><span class="pre">get_bloch_states</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">flatten_spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray.get_bloch_states"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray.get_bloch_states" title="Link to this definition">#</a></dt>
<dd><p>Returns Bloch and cell-periodic states from the WFArray.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.0.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>flatten_spin</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, the spin and orbital indices are flattened into a single index and
the shape of the returned states will be [nk1, …, nkd, [n_lambda,] n_state, n_orb * n_spin].
If False, the original shape is preserved, [nk1, …, nkd, [n_lambda,] n_state, n_orb, n_spin].</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>states</strong> – A dictionary containing the “bloch” and “cell” states.  The returned dictionary
has the following keys:</p>
<ul class="simple">
<li><p>”bloch”: Bloch states (periodic in k-space) <span class="math notranslate nohighlight">\(\psi_{n\mathbf{k}}(\mathbf{r})\)</span></p></li>
<li><p>”cell”: Cell-periodic states (periodic in real space) <span class="math notranslate nohighlight">\(u_{n\mathbf{k}}(\mathbf{r})\)</span></p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)">dict</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#pythtb.WFArray.get_states" title="pythtb.WFArray.get_states"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_states</span></code></a></dt><dd><p>For obtaining the states stored on the mesh only.</p>
</dd>
</dl>
<p><a class="reference internal" href="../formalism.html#formalism"><span class="std std-ref">Formalism</span></a></p>
</div>
<p class="rubric">Notes</p>
<p>This function assumes that the WFArray is defined on a regular k-mesh.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pythtb.WFArray.get_projectors">
<span class="sig-name descname"><span class="pre">get_projectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_Q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray.get_projectors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray.get_projectors" title="Link to this definition">#</a></dt>
<dd><p>Returns the band projectors associated with the states in the WFArray.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.0.0.</span></p>
</div>
<p>The band projectors are defined as the outer product of the wavefunctions:</p>
<div class="math notranslate nohighlight">
\[\begin{split}P_{n\mathbf{k}} = |u_{n\mathbf{k}}(\mathbf{r})\rangle \langle u_{n\mathbf{k}}(\mathbf{r})| \\
Q_{n\mathbf{k}} = \mathbb{I} - P_{n\mathbf{k}}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_Q</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, the function also returns the orthogonal projector Q.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>P</strong> (<em>np.ndarray</em>) – The band projectors.</p></li>
<li><p><strong>Q</strong> (<em>np.ndarray, optional</em>) – The orthogonal projectors.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pythtb.WFArray.solve_k_mesh">
<span class="sig-name descname"><span class="pre">solve_k_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lambda_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">auto_detect_pbc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray.solve_k_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray.solve_k_mesh" title="Link to this definition">#</a></dt>
<dd><p>Solve the Hamiltonian on the k-mesh for a given parameter slice.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.0.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lambda_idx</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – The index of the parameter slice to solve for. If None, solves for all slices.</p></li>
<li><p><strong>auto_detect_pbc</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, automatically detects and imposes periodic boundary conditions (PBC) for the k-mesh.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pythtb.WFArray.solve_on_path">
<span class="sig-name descname"><span class="pre">solve_on_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k_arr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray.solve_on_path"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray.solve_on_path" title="Link to this definition">#</a></dt>
<dd><p>Solve the model along a 1D parameter path (e.g., k-points).
Stores eigenvectors and eigenvalues along this path.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>k_arr</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_points</em><em>, </em><em>dim_k</em><em>)</em>) – Sequence of points (e.g., k-points) at which to solve the model.
Must match the model’s dim_k and the WFArray’s mesh_size[0].</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>energies</strong> (<em>ndarray, shape (n_points, nstates)</em>) – Eigenvalues at each point along the path.</p></li>
<li><p><strong>wfs</strong> (<em>ndarray, shape (n_points, nstates, norb[, nspin])</em>) – Corresponding eigenvectors stored in the WFArray.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pythtb.WFArray.solve_on_grid">
<span class="sig-name descname"><span class="pre">solve_on_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray.solve_on_grid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray.solve_on_grid" title="Link to this definition">#</a></dt>
<dd><p>Solve a tight-binding model on a regular mesh of k-points.</p>
<p>The regular mesh of k-points covers the entire reciprocal-space unit cell.
Both points at the opposite sides of reciprocal-space unit cell are included
in the array. The spacing between points is defined by the mesh size specified
upon initialization. The end point is <code class="docutils literal notranslate"><span class="pre">[start_k[0]+1,</span> <span class="pre">start_k[1]+1]</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>start_k</strong> (<em>array-like</em><em> (</em><em>dim_k</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – The starting point of the k-mesh in reciprocal space. If not specified,
defaults to [0, 0] for 2D systems, [0, 0, 0] for 3D systems, etc. The
starting point along each dimension must be in the range [-0.5, 0.5].</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>gaps</strong> – The minimal direct bandgap between <cite>n</cite>-th and <cite>n+1</cite>-th band on
all the k-points in the mesh.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pythtb.WFArray.impose_pbc" title="pythtb.WFArray.impose_pbc"><code class="xref py py-func docutils literal notranslate"><span class="pre">pythtb.WFArray.impose_pbc()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>One may have to use a dense k-mesh to resolve the highly-dispersive crossings.</p>
<p>This function also automatically imposes periodic boundary
conditions on the eigenfunctions. See also the discussion in
<a class="reference internal" href="#pythtb.WFArray.impose_pbc" title="pythtb.WFArray.impose_pbc"><code class="xref py py-func docutils literal notranslate"><span class="pre">pythtb.WFArray.impose_pbc()</span></code></a>.</p>
<p class="rubric">Examples</p>
<p>Solve eigenvectors on a regular grid anchored at <code class="docutils literal notranslate"><span class="pre">[-0.5,</span> <span class="pre">-0.5]</span></code>
so that the mesh is defined from <code class="docutils literal notranslate"><span class="pre">[-0.5,</span> <span class="pre">-0.5]</span></code> to <code class="docutils literal notranslate"><span class="pre">[0.5,</span> <span class="pre">0.5]</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wf</span><span class="o">.</span><span class="n">solve_on_grid</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pythtb.WFArray.solve_on_one_point">
<span class="sig-name descname"><span class="pre">solve_on_one_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kpt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_indices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray.solve_on_one_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray.solve_on_one_point" title="Link to this definition">#</a></dt>
<dd><p>Solve a tight-binding model on a single k-point.</p>
<p>Solve a tight-binding model on a single k-point and store the eigenvectors
in the <em>WFArray</em> object in the location specified by <em>mesh_indices</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kpt</strong> (<em>List specifying desired k-point to solve the model on.</em>)</p></li>
<li><p><strong>mesh_indices</strong> (<em>List specifying associated set</em><em> of </em><em>mesh indices to assign the wavefunction to.</em>)</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Solve eigenvectors on a sphere of radius kappa surrounding
point <cite>k_0</cite> in 3d k-space and pack into a predefined 2d WFArray</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wf</span> <span class="o">=</span> <span class="n">WFArray</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kappa</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k_0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">i</span> <span class="o">/</span> <span class="n">n</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">phi</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">j</span> <span class="o">/</span> <span class="n">m</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">kx</span> <span class="o">=</span> <span class="n">k_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">kappa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">ky</span> <span class="o">=</span> <span class="n">k_0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">kappa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">kz</span> <span class="o">=</span> <span class="n">k_0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">kappa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">wf</span><span class="o">.</span><span class="n">solve_on_one_point</span><span class="p">([</span><span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">kz</span><span class="p">],</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pythtb.WFArray.choose_states">
<span class="sig-name descname"><span class="pre">choose_states</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subset</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray.choose_states"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray.choose_states" title="Link to this definition">#</a></dt>
<dd><p>Create a new <em>WFArray</em> object containing a subset of the
states in the original one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>subset</strong> (<em>array-like</em><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – State indices to keep.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>wf_new</strong> – Identical in all respects except that a subset of states have been kept.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#pythtb.WFArray" title="pythtb.WFArray">WFArray</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Make new <em>WFArray</em> object containing only two states</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wf_new</span> <span class="o">=</span> <span class="n">wf</span><span class="o">.</span><span class="n">choose_states</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pythtb.WFArray.empty_like">
<span class="sig-name descname"><span class="pre">empty_like</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nstates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray.empty_like"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray.empty_like" title="Link to this definition">#</a></dt>
<dd><p>Create a new empty <em>WFArray</em> object based on the original.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nstates</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Specifies the number of states (or bands) to be stored in the array.
Defaults to the same as the original <em>WFArray</em> object.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>wf_new</strong> – WFArray except that array elements are uninitialized and
the number of states may have changed.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#pythtb.WFArray" title="pythtb.WFArray">WFArray</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Make new empty WFArray object containing 6 bands per k-point</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wf_new</span><span class="o">=</span><span class="n">wf</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">nstates</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pythtb.WFArray.impose_pbc">
<span class="sig-name descname"><span class="pre">impose_pbc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_dir</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray.impose_pbc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray.impose_pbc" title="Link to this definition">#</a></dt>
<dd><p>Impose periodic boundary conditions on the WFArray.</p>
<p>This routine sets the cell-periodic Bloch function
at the end of the mesh in direction <cite>k_dir</cite> equal to the first,
multiplied by a phase factor, overwriting the previous value.
Explicitly, this means we set
<span class="math notranslate nohighlight">\(u_{n,{\bf k_0+G}}=e^{-i{\bf G}\cdot{\bf r}} u_{n {\bf k_0}}\)</span> for the
corresponding reciprocal lattice vector <span class="math notranslate nohighlight">\(\mathbf{G} = \mathbf{b}_{\texttt{k_dir}}\)</span>,
where <span class="math notranslate nohighlight">\(\mathbf{b}_{\texttt{k_dir}}\)</span> is the reciprocal lattice basis vector corresponding to the
direction <cite>k_dir</cite>. The state <span class="math notranslate nohighlight">\(u_{n{\bf k_0}}\)</span> is the state populated in the first element
of the mesh along the <cite>mesh_dir</cite> axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh_dir</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – Direction of <cite>WFArray</cite> along which you wish to impose periodic boundary conditions.</p></li>
<li><p><strong>k_dir</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – Corresponding to the periodic k-vector direction
in the Brillouin zone of the underlying <em>TBModel</em>. Since
version 1.7.0 this parameter is defined so that it is
specified between 0 and <em>dim_r-1</em>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="../examples_ipynb/3site_cycle.html#site-cycle-nb"><span class="std std-ref">1D cycle of 1D tight-binding model</span></a></dt><dd><p>For an example where the periodic boundary</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">condition</span></code></p>
<dl class="simple">
<dt><a class="reference internal" href="../formalism.html#formalism"><span class="std std-ref">Formalism</span></a></dt><dd><p>Section 4.4 and equation 4.18</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>If the <em>WFArray</em> object was populated using the
<a class="reference internal" href="#pythtb.WFArray.solve_on_grid" title="pythtb.WFArray.solve_on_grid"><code class="xref py py-func docutils literal notranslate"><span class="pre">pythtb.WFArray.solve_on_grid()</span></code></a> method, this function
should not be used since it will be called automatically by
the code.</p>
<p>This function will impose these periodic boundary conditions along
one direction of the array. We are assuming that the k-point
mesh increases by exactly one reciprocal lattice vector along
this direction. This is currently <strong>not</strong> checked by the code;
it is the responsibility of the user. Currently <em>WFArray</em>
does not store the k-vectors on which the model was solved;
it only stores the eigenvectors (wavefunctions).</p>
<p>The eigenfunctions <span class="math notranslate nohighlight">\(\psi_{n {\bf k}}\)</span> are by convention
chosen to obey a periodic gauge, i.e.,
<span class="math notranslate nohighlight">\(\psi_{n,{\bf k+G}}=\psi_{n {\bf k}}\)</span> not only up to a
phase, but they are also equal in phase. It follows that
the cell-periodic Bloch functions are related by
<span class="math notranslate nohighlight">\(u_{n,{\bf k_0+G}}=e^{-i{\bf G}\cdot{\bf r}} u_{n {\bf k_0}}\)</span>.
See <a class="reference download internal" download="" href="../_downloads/e39c23ce476d399b268efa520e7a9091/pythtb-formalism.pdf"><code class="xref download docutils literal notranslate"><span class="pre">notes</span> <span class="pre">on</span> <span class="pre">tight-binding</span> <span class="pre">formalism</span></code></a>
section 4.4 and equation 4.18 for more detail.</p>
<p class="rubric">Examples</p>
<p>Imposes periodic boundary conditions along the mesh_dir=0
direction of the <cite>WFArray</cite> object, assuming that along that
direction the <cite>k_dir=1</cite> component of the k-vector is increased
by one reciprocal lattice vector.  This could happen, for
example, if the underlying TBModel is two dimensional but
<cite>WFArray</cite> is a one-dimensional path along <span class="math notranslate nohighlight">\(k_y\)</span> direction.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wf</span><span class="o">.</span><span class="n">impose_pbc</span><span class="p">(</span><span class="n">mesh_dir</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">k_dir</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pythtb.WFArray.impose_loop">
<span class="sig-name descname"><span class="pre">impose_loop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh_dir</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray.impose_loop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray.impose_loop" title="Link to this definition">#</a></dt>
<dd><p>Impose a loop condition along a given mesh direction.</p>
<p>This routine can be used to set the
eigenvectors equal (with equal phase), by replacing the last
eigenvector with the first one along the <cite>mesh_dir</cite> direction
(for each band).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mesh_dir</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – Direction of <cite>WFArray</cite> along which you wish to
impose periodic boundary conditions.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pythtb.WFArray.impose_pbc" title="pythtb.WFArray.impose_pbc"><code class="xref py py-func docutils literal notranslate"><span class="pre">pythtb.WFArray.impose_pbc()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This routine should not be used if the first and last points
are related by a reciprocal lattice vector; in that case,
<a class="reference internal" href="#pythtb.WFArray.impose_pbc" title="pythtb.WFArray.impose_pbc"><code class="xref py py-func docutils literal notranslate"><span class="pre">pythtb.WFArray.impose_pbc()</span></code></a> should be used instead.</p>
<p>It is assumed that the first and last points along the
<cite>mesh_dir</cite> direction correspond to the same Hamiltonian (this
is <strong>not</strong> checked).</p>
<p class="rubric">Examples</p>
<p>Suppose the WFArray object is three-dimensional
corresponding to <cite>(kx, ky, lambda)</cite> where <cite>(kx, ky)</cite> are
wavevectors of a 2D insulator and lambda is an
adiabatic parameter that goes around a closed loop.
Then to insure that the states at the ends of the lambda
path are equal (with equal phase) in preparation for
computing Berry phases in lambda for given <cite>(kx, ky)</cite>,
do</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wf</span><span class="o">.</span><span class="n">impose_loop</span><span class="p">(</span><span class="n">mesh_dir</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pythtb.WFArray.position_matrix">
<span class="sig-name descname"><span class="pre">position_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k_idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dir</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray.position_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray.position_matrix" title="Link to this definition">#</a></dt>
<dd><p>Position matrix for a given k-point and set of states.</p>
<p>Position operator is defined in reduced coordinates.
The returned object <span class="math notranslate nohighlight">\(X\)</span> is</p>
<div class="math notranslate nohighlight">
\[X_{m n {\bf k}}^{\alpha} = \langle u_{m {\bf k}} \vert
r^{\alpha} \vert u_{n {\bf k}} \rangle\]</div>
<p>Here <span class="math notranslate nohighlight">\(r^{\alpha}\)</span> is the position operator along direction
<span class="math notranslate nohighlight">\(\alpha\)</span> that is selected by <cite>dir</cite>.</p>
<p>This routine can be used to compute the position matrix for a
given k-point and set of states (which can be all states, or
a specific subset).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k_idx</strong> (<em>array-like</em><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – Set of integers specifying the k-point of interest in the mesh.</p></li>
<li><p><strong>occ</strong> (<em>array-like</em><em>, </em><em>'all'</em>) – List of states to be included (can be ‘all’ to include all states).</p></li>
<li><p><strong>dir</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – Direction along which to compute the position matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>pos_mat</strong> – Position operator matrix <span class="math notranslate nohighlight">\(X_{m n}\)</span> as defined above.
This is a square matrix with size determined by number of bands
given in <cite>evec</cite> input array.  First index of <cite>pos_mat</cite> corresponds to
bra vector (<span class="math notranslate nohighlight">\(m\)</span>) and second index to ket (<span class="math notranslate nohighlight">\(n\)</span>).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="pythtb.TBModel.html#pythtb.TBModel.position_matrix" title="pythtb.TBModel.position_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">pythtb.TBModel.position_matrix()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The only difference in <a class="reference internal" href="pythtb.TBModel.html#pythtb.TBModel.position_matrix" title="pythtb.TBModel.position_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">pythtb.TBModel.position_matrix()</span></code></a> is that,
in addition to specifying <cite>dir</cite>, one also has to specify <cite>k_idx</cite> (k-point of interest)
and <cite>occ</cite> (list of states to be included, which can optionally be ‘all’).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pythtb.WFArray.position_expectation">
<span class="sig-name descname"><span class="pre">position_expectation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k_idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dir</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray.position_expectation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray.position_expectation" title="Link to this definition">#</a></dt>
<dd><p>Position expectation value for a given k-point and set of states.</p>
<p>These elements <span class="math notranslate nohighlight">\(X_{n n}\)</span> can be interpreted as an
average position of n-th Bloch state <code class="docutils literal notranslate"><span class="pre">evec[n]</span></code> along
direction <cite>dir</cite>.</p>
<p>This routine can be used to compute the position expectation value for a
given k-point and set of states (which can be all states, or
a specific subset).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k_idx</strong> (<em>array-like</em><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – Set of integers specifying the k-point of interest in the mesh.</p></li>
<li><p><strong>occ</strong> (<em>array-like</em><em>, </em><em>'all'</em>) – List of states to be included (can be ‘all’ to include all states).</p></li>
<li><p><strong>dir</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – Direction along which to compute the position expectation value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>pos_exp</strong> – Diagonal elements of the position operator matrix <span class="math notranslate nohighlight">\(X\)</span>.
Length of this vector is determined by number of bands given in <em>evec</em> input
array.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="pythtb.TBModel.html#pythtb.TBModel.position_expectation" title="pythtb.TBModel.position_expectation"><code class="xref py py-func docutils literal notranslate"><span class="pre">pythtb.TBModel.position_expectation()</span></code></a></p>
<dl class="simple">
<dt><a class="reference internal" href="../examples_ipynb/haldane_hwf.html#haldane-hwf-nb"><span class="std std-ref">Haldane model hybrid Wannier functions</span></a></dt><dd><p>For an example.</p>
</dd>
<dt><a class="reference internal" href="#pythtb.WFArray.position_matrix" title="pythtb.WFArray.position_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">position_matrix</span></code></a></dt><dd><p>For definition of matrix <span class="math notranslate nohighlight">\(X\)</span>.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The only difference in <a class="reference internal" href="pythtb.TBModel.html#pythtb.TBModel.position_expectation" title="pythtb.TBModel.position_expectation"><code class="xref py py-func docutils literal notranslate"><span class="pre">pythtb.TBModel.position_expectation()</span></code></a> is that,
in addition to specifying <em>dir</em>, one also has to specify <em>k_idx</em> (k-point of interest)
and <em>occ</em> (list of states to be included, which can optionally be ‘all’).</p>
<p>Generally speaking these centers are _not_
hybrid Wannier function centers (which are instead
returned by <a class="reference internal" href="#pythtb.WFArray.position_hwf" title="pythtb.WFArray.position_hwf"><code class="xref py py-func docutils literal notranslate"><span class="pre">position_hwf()</span></code></a>).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pythtb.WFArray.position_hwf">
<span class="sig-name descname"><span class="pre">position_hwf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k_idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hwf_evec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'wavefunction'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray.position_hwf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray.position_hwf" title="Link to this definition">#</a></dt>
<dd><p>Eigenvalues and eigenvectors of the position operator in a given basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k_idx</strong> (<em>array-like</em><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – Set of integers specifying the k-point of interest in the mesh.</p></li>
<li><p><strong>occ</strong> (<em>array-like</em><em>, </em><em>'all'</em>) – List of states to be included (can be ‘all’ to include all states).</p></li>
<li><p><strong>dir</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – Direction along which to compute the position operator.</p></li>
<li><p><strong>hwf_evec</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Default is <cite>False</cite>. If <cite>True</cite>, return the eigenvectors along with eigenvalues
of the position operator.</p></li>
<li><p><strong>basis</strong> (<em>{&quot;orbital&quot;</em><em>, </em><em>&quot;wavefunction&quot;</em><em>, </em><em>&quot;bloch&quot;}</em><em>, </em><em>optional</em>) – The basis in which to compute the position operator.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul>
<li><p><strong>hwfc</strong> (<em>np.ndarray</em>) – Eigenvalues of the position operator matrix <span class="math notranslate nohighlight">\(X\)</span>
(also called hybrid Wannier function centers).
Length of this vector equals number of bands given in <em>evec</em> input
array.  Hybrid Wannier function centers are ordered in ascending order.
Note that in general <cite>n</cite>-th hwfc does not correspond to <cite>n</cite>-th electronic
state <cite>evec</cite>.</p></li>
<li><p><strong>hwf</strong> (<em>np.ndarray</em>) – Eigenvectors of the position operator matrix <span class="math notranslate nohighlight">\(X\)</span>.
(also called hybrid Wannier functions).  These are returned only if
parameter <code class="docutils literal notranslate"><span class="pre">hwf_evec=True</span></code>.</p>
<p>The shape of this array is <code class="docutils literal notranslate"><span class="pre">[h,x]</span></code> or <code class="docutils literal notranslate"><span class="pre">[h,x,s]</span></code> depending on value of
<cite>basis</cite> and <cite>nspin</cite>.</p>
<ul class="simple">
<li><p>If <cite>basis</cite> is “bloch” then <cite>x</cite> refers to indices of
Bloch states <cite>evec</cite>.</p></li>
<li><p>If <cite>basis</cite> is “orbital” then <cite>x</cite> (or <cite>x</cite> and <cite>s</cite>)
correspond to orbital index (or orbital and spin index if <cite>nspin</cite> is 2).</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="../examples_ipynb/haldane_hwf.html#haldane-hwf-nb"><span class="std std-ref">Haldane model hybrid Wannier functions</span></a></dt><dd><p>For an example.</p>
</dd>
<dt><a class="reference internal" href="#pythtb.WFArray.position_matrix" title="pythtb.WFArray.position_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">position_matrix</span></code></a></dt><dd><p>For the definition of the matrix <span class="math notranslate nohighlight">\(X\)</span>.</p>
</dd>
<dt><a class="reference internal" href="#pythtb.WFArray.position_expectation" title="pythtb.WFArray.position_expectation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">position_expectation</span></code></a></dt><dd><p>For the position expectation value.</p>
</dd>
</dl>
<p><a class="reference internal" href="pythtb.TBModel.html#pythtb.TBModel.position_hwf" title="pythtb.TBModel.position_hwf"><code class="xref py py-func docutils literal notranslate"><span class="pre">pythtb.TBModel.position_hwf()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Similar to <a class="reference internal" href="pythtb.TBModel.html#pythtb.TBModel.position_hwf" title="pythtb.TBModel.position_hwf"><code class="xref py py-func docutils literal notranslate"><span class="pre">pythtb.TBModel.position_hwf()</span></code></a>, except that
in addition to specifying <em>dir</em>, one also has to specify
<em>k_idx</em>, the k-point of interest, and <em>occ</em>, a list of states to
be included (typically the occupied states).</p>
<p>For backwards compatibility the default value of <em>basis</em> here is different
from that in <a class="reference internal" href="pythtb.TBModel.html#pythtb.TBModel.position_hwf" title="pythtb.TBModel.position_hwf"><code class="xref py py-func docutils literal notranslate"><span class="pre">pythtb.TBModel.position_hwf()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pythtb.WFArray.get_links">
<span class="sig-name descname"><span class="pre">get_links</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dirs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray.get_links"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray.get_links" title="Link to this definition">#</a></dt>
<dd><p>Compute the overlap links (unitary matrices) for the wavefunctions.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.0.0.</span></p>
</div>
<p>The overlap links for the wavefunctions in the <cite>WFArray</cite> object
along a given direction are defined as the unitary part of the overlap
between the wavefunctions and their neighbors in the forward direction along each
mesh directions. Specifcally, the overlap matrices are computed as</p>
<div class="math notranslate nohighlight">
\[M_{nm}^{\mu}(\mathbf{k}) = \langle u_{nk} | u_{m, k + \delta k_{\mu}} \rangle\]</div>
<p>where <span class="math notranslate nohighlight">\(\mu\)</span> is the direction along which the link is computed, and
<span class="math notranslate nohighlight">\(\delta k_{\mu}\)</span> is the shift in the wavevector along that direction. The
<span class="math notranslate nohighlight">\(k\)</span> here could be a point in an arbitrary parameter mesh. The unitary link that
is returned by the function is obtained through the singular value decomposition
(SVD) of the overlap matrix <span class="math notranslate nohighlight">\(M^{\mu}(\mathbf{k}) = V^{\mu} \Sigma^{\mu} (W^{\mu})^\dagger\)</span>
as,</p>
<div class="math notranslate nohighlight">
\[U^{\mu}(\mathbf{k}) = V^{\mu} (W^{\mu})^\dagger\]</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The neighbor at the boundary is defined with periodic boundary conditions by default.
In most cases, this means that the last point in the mesh of <span class="math notranslate nohighlight">\(U^{\mu}(\mathbf{k})\)</span>
along each direction should be disregarded (see Notes for further details).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state_idx</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – Index or indices of the states for which to compute the links.
If an integer is provided, only that state will be considered.
If a list is provided, links for all specified states will be computed.</p></li>
<li><p><strong>dirs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – List of directions along which to compute the links.
If not provided, links will be computed for all directions in the mesh.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Array of shape [dim, nk1, nk2, …, nkd, n_states, n_states]
where dim is the number of dimensions of the mesh,
(nk1, nk2, …, nkd) are the sizes of the mesh in each dimension,
and n_states is the number of states in the <em>WFArray</em> object. The first
axis corresponds to <span class="math notranslate nohighlight">\(\mu\)</span>, the last two axes are the matrix elements,
and the remaining axes are the mesh points.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>U_forward (np.ndarray)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The last points in the mesh of <cite>U_forward</cite> should be treated carefully. Periodic boundary
conditions are always implied here, so that the 0’th wavefunction is the forward neighbor of
the last wavefunction (-1’st element) along each direction. If the <cite>WFArray</cite> mesh has already
been defined with periodic boundary conditions, with either <a class="reference internal" href="#pythtb.WFArray.impose_pbc" title="pythtb.WFArray.impose_pbc"><code class="xref py py-func docutils literal notranslate"><span class="pre">impose_pbc()</span></code></a> or <a class="reference internal" href="#pythtb.WFArray.impose_loop" title="pythtb.WFArray.impose_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">impose_loop()</span></code></a>,
then the last points are identified with the first points. This means the overlap links at the boundary
should be disregarded, since the overlap is not between neighbors. If the last and first wavefunctions
are not neighbors, then the forward neighbor at the boundary is undefined and the value
of <span class="math notranslate nohighlight">\(U_{nk}^{\mu}\)</span> at the boundary can again be disregarded. The only time these points should not be
disregarded is when the last and first wavefunctions are truly neighbors, which would only happen if
the wavefunctions on the mesh were manually populated that way.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pythtb.WFArray.wilson_loop">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">wilson_loop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wfs_loop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray.wilson_loop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray.wilson_loop" title="Link to this definition">#</a></dt>
<dd><p>Wilson loop unitary matrix</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.0.0.</span></p>
</div>
<p>Compute Wilson loop unitary matrix and its eigenvalues for multiband Berry phases.
The Wilson loop is a geometric quantity that characterizes the topology of the
band structure. It is defined as the product of the overlap matrices between
neighboring wavefunctions in the loop. Specifically, it is given by</p>
<div class="math notranslate nohighlight">
\[U_{Wilson} = \prod_{n} U_{n}\]</div>
<p>where <span class="math notranslate nohighlight">\(U_{n}\)</span> is the unitary part of the overlap matrix between neighboring wavefunctions
in the loop, and the index <span class="math notranslate nohighlight">\(n\)</span> labels the position in the loop
(see <a class="reference internal" href="#pythtb.WFArray.get_links" title="pythtb.WFArray.get_links"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_links()</span></code></a> for more details).</p>
<p>Multiband Berry phases always returns numbers between <span class="math notranslate nohighlight">\(-\pi\)</span> and <span class="math notranslate nohighlight">\(\pi\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wfs_loop</strong> (<em>np.ndarray</em>) – Has format [loop_idx, band, orbital(, spin)] and loop has to be one dimensional.
Assumes that first and last loop-point are the same. Therefore if
there are n wavefunctions in total, will calculate phase along n-1
links only!</p></li>
<li><p><strong>berry_evals</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If berry_evals is True then will compute phases for
individual states, these corresponds to 1d hybrid Wannier
function centers. Otherwise just return one number, Berry phase.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If berry_evals is True then will return phases for individual states.
If berry_evals is False then will return one number, the Berry phase.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pythtb.WFArray.berry_loop" title="pythtb.WFArray.berry_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">berry_loop()</span></code></a>, <a class="reference internal" href="#pythtb.WFArray.get_links" title="pythtb.WFArray.get_links"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_links()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pythtb.WFArray.berry_loop">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">berry_loop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wfs_loop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray.berry_loop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray.berry_loop" title="Link to this definition">#</a></dt>
<dd><p>Berry phase along a one-dimensional loop of wavefunctions.</p>
<p>The Berry phase is computed as the logarithm of the determinant
of the product of the overlap matrices between neighboring
wavefunctions in the loop. In otherwords, the Berry phase is
given by the formula:</p>
<div class="math notranslate nohighlight">
\[\phi = -\text{Im} \ln \det U_{\rm Wilson}\]</div>
<p>where <span class="math notranslate nohighlight">\(U\)</span> is the Wilson loop unitary matrix obtained from
<a class="reference internal" href="#pythtb.WFArray.wilson_loop" title="pythtb.WFArray.wilson_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">wilson_loop()</span></code></a>. The Berry phase is returned as a
single number, which is the total Berry phase for the loop.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wfs_loop</strong> (<em>np.ndarray</em>) – Wavefunctions in the loop, with shape <cite>[loop_idx, band, orbital, spin]</cite>.
The first and last points in the loop are assumed to be the same.</p></li>
<li><p><strong>evals</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Default is <cite>False</cite>. If <cite>True</cite>, will return the eigenvalues
of the Wilson loop unitary matrix instead of the total Berry phase.
The eigenvalues correspond to the “maximally localized Wannier centers” or
“Wilson loop eigenvalues”. If False, will return the total
Berry phase for the loop.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If evals is True, returns the eigenvalues of the Wilson loop
unitary matrix, which are the Berry phases for each band.
If evals is False, returns the total Berry phase for the loop,
which is a single number.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray, <a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)">float</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pythtb.WFArray.berry_phase" title="pythtb.WFArray.berry_phase"><code class="xref py py-func docutils literal notranslate"><span class="pre">berry_phase()</span></code></a>, <a class="reference internal" href="#pythtb.WFArray.get_links" title="pythtb.WFArray.get_links"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_links()</span></code></a>, <a class="reference internal" href="#pythtb.WFArray.wilson_loop" title="pythtb.WFArray.wilson_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">wilson_loop()</span></code></a></p>
<dl class="simple">
<dt><a class="reference internal" href="../formalism.html#formalism"><span class="std std-ref">Formalism</span></a></dt><dd><p>Section 4.5</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The loop is assumed to be one-dimensional, meaning that the first
and last points in the loop are assumed to be the same, and the wavefunctions
at these points are also assumed to be the same. The wavefunctions in the loop
should be ordered such that the first point corresponds to the first wavefunction,
the second point to the second wavefunction, and so on, up to the last point,
which corresponds to the last wavefunction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pythtb.WFArray.berry_phase">
<span class="sig-name descname"><span class="pre">berry_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'All'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">berry_evals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray.berry_phase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray.berry_phase" title="Link to this definition">#</a></dt>
<dd><p>Berry phase along a given array direction.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.0.0.</span></p>
</div>
<p>Computes the Berry phase along a given array direction
and for a given set of states. These are typically the
occupied Bloch states, but can also include unoccupied
states if desired.</p>
<p>By default, the function returns the Berry phase traced
over the specified set of bands, but optionally the individual
phases of the eigenvalues of the global unitary rotation
matrix (corresponding to “maximally localized Wannier
centers” or “Wilson loop eigenvalues”) can be requested
by setting the parameter <em>berry_evals</em> to <cite>True</cite>.</p>
<p>For a one-dimensional WFArray (i.e., a single string), the
computed Berry phases are always chosen to be between <span class="math notranslate nohighlight">\(-\pi\)</span>
and <span class="math notranslate nohighlight">\(\pi\)</span>. For a higher dimensional WFArray, the Berry phase
is computed for each one-dimensional string of points, and an array of
Berry phases is returned. The Berry phase for the first string
(with lowest index) is always constrained to be between <span class="math notranslate nohighlight">\(-\pi\)</span> and
<span class="math notranslate nohighlight">\(\pi\)</span>. The range of the remaining phases depends on the value of
the input parameter <cite>contin</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>occ</strong> (<em>array-like</em><em>, </em><em>&quot;all&quot;</em>) – Optional array of indices of states to be included
in the subsequent calculations, typically the indices of
bands considered occupied. If ‘all’, all states are selected.
Default is all bands.</p></li>
<li><p><strong>dir</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – Index of WFArray direction along which Berry phase is
computed. This parameters needs not be specified for
a one-dimensional WFArray.</p></li>
<li><p><strong>contin</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If True then the branch choice of the Berry phase (which is indeterminate
modulo <span class="math notranslate nohighlight">\(2\pi\)</span>) is made so that neighboring strings (in the
direction of increasing index value) have as close as
possible phases. The phase of the first string (with lowest
index) is always constrained to be between <span class="math notranslate nohighlight">\(-\pi\)</span> and <span class="math notranslate nohighlight">\(\pi\)</span>.
If False, the Berry phase for every string is constrained to be
between <span class="math notranslate nohighlight">\(-\pi\)</span> and <span class="math notranslate nohighlight">\(\pi\)</span>. The default value is True.</p></li>
<li><p><strong>berry_evals</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If True then will compute and return the phases of the eigenvalues of the
product of overlap matrices. (These numbers correspond also
to hybrid Wannier function centers.) These phases are either
forced to be between <span class="math notranslate nohighlight">\(-\pi\)</span> and <span class="math notranslate nohighlight">\(\pi\)</span> (if <em>contin</em> is <em>False</em>) or
they are made to be continuous (if <em>contin</em> is True).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If <em>berry_evals</em> is False (default value) then
returns the Berry phase for each string. For a
one-dimensional WFArray this is just one number. For a
higher-dimensional <cite>WFArray</cite> <em>pha</em> contains one phase for
each one-dimensional string in the following format. For
example, if <em>WFArray</em> contains k-points on mesh with
indices <cite>[i,j,k]</cite> and if direction along which Berry phase
is computed is <em>dir=1</em> then <em>pha</em> will be two dimensional
array with indices <cite>[i,k]</cite>, since Berry phase is computed
along second direction. If <em>berry_evals</em> is True then for
each string returns phases of all eigenvalues of the
product of overlap matrices. In the convention used for
previous example, <em>pha</em> in this case would have indices
<cite>[i,k,n]</cite> where <em>n</em> refers to index of individual phase of
the product matrix eigenvalue.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pha</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="../examples_ipynb/haldane_bp.html#haldane-bp-nb"><span class="std std-ref">Haldane model Berry phases and curvatures</span></a></dt><dd><p>For an example</p>
</dd>
<dt><a class="reference internal" href="../examples_ipynb/graphene_cone.html#cone-nb"><span class="std std-ref">Berry phase around graphene’s Dirac cone</span></a></dt><dd><p>For an example</p>
</dd>
<dt><a class="reference internal" href="../examples_ipynb/3site_cycle.html#site-cycle-nb"><span class="std std-ref">1D cycle of 1D tight-binding model</span></a></dt><dd><p>For an example</p>
</dd>
<dt><a class="reference internal" href="#pythtb.WFArray.berry_loop" title="pythtb.WFArray.berry_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">berry_loop()</span></code></a></dt><dd><p>For a function that computes Berry phase in a 1d loop.</p>
</dd>
<dt><a class="reference internal" href="../formalism.html#formalism"><span class="std std-ref">Formalism</span></a></dt><dd><p>Sec. 4.5 for the discretized formula used to compute Berry phase.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For an array of size <em>N</em> in direction $dir$, the Berry phase
is computed from the <em>N-1</em> inner products of neighboring
eigenfunctions. This corresponds to an “open-path Berry
phase” if the first and last points have no special
relation. If they correspond to the same physical
Hamiltonian, and have been properly aligned in phase using
<a class="reference internal" href="#pythtb.WFArray.impose_pbc" title="pythtb.WFArray.impose_pbc"><code class="xref py py-func docutils literal notranslate"><span class="pre">pythtb.WFArray.impose_pbc()</span></code></a> or <a class="reference internal" href="#pythtb.WFArray.impose_loop" title="pythtb.WFArray.impose_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">pythtb.WFArray.impose_loop()</span></code></a>,
then a closed-path Berry phase will be computed.</p>
<p>In the case <em>occ</em> should range over all occupied bands,
the occupied and unoccupied bands should be well separated in energy;
it is the responsibility of the user to check that this is satisfied.</p>
<p class="rubric">Examples</p>
<p>Computes Berry phases along second direction for three lowest
occupied states. For example, if wf is threedimensional, then
<code class="docutils literal notranslate"><span class="pre">pha[2,</span> <span class="pre">3]</span></code> would correspond to Berry phase of string of states
along <code class="docutils literal notranslate"><span class="pre">wf[2,</span> <span class="pre">:,</span> <span class="pre">3]</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pha</span> <span class="o">=</span> <span class="n">wf</span><span class="o">.</span><span class="n">berry_phase</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pythtb.WFArray.berry_flux">
<span class="sig-name descname"><span class="pre">berry_flux</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plane</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">abelian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray.berry_flux"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray.berry_flux" title="Link to this definition">#</a></dt>
<dd><p>Berry flux tensor.</p>
<div class="versionremoved">
<p><span class="versionmodified removed">Removed in version 2.0.0: </span>The <cite>individual_phases</cite> parameter has been removed.</p>
</div>
<p>The Berry flux tensor is a measure of the geometric phase acquired by
the wavefunction as it is adiabatically transported around a closed loop
in parameter space. The flux is computed around the small plaquettes in
the parameter mesh, using the product of overlap matrices around the loops.
The Berry flux is simply the integral of the Berry curvature around the plaquette
loop. The (non-Abelian) Berry flux tensor is defined as</p>
<div class="math notranslate nohighlight">
\[\mathcal{F}_{\mu\nu}(\mathbf{k}) =
\mathrm{Im}\ln\det[U_{\mu}(\mathbf{k}) U_{\nu}(\mathbf{k} + \hat{\mu})
U_{\mu}^{-1}(\mathbf{k} + \hat{\nu}) U_{\nu}^{-1}(\mathbf{k})].\]</div>
<p>The Berry curvature can be approximated by the flux by simply dividing by the
area of the plaquette, approximating the flux as a constant over the small loop.</p>
<div class="math notranslate nohighlight">
\[\Omega_{\mu\nu}(\mathbf{k}) \approx \frac{\mathcal{F}_{\mu\nu}(\mathbf{k})}{A_{\mu\nu}},\]</div>
<p>where <span class="math notranslate nohighlight">\(A_{\mu\nu}\)</span> is the area of the plaquette in parameter space. The
Abelian Berry flux is defined as the trace over the band indices of the non-Abelian
Berry flux tensor.</p>
<div class="math notranslate nohighlight">
\[\mathcal{F}_{\mu\nu}(\mathbf{k}) = \sum_{n} (\mathcal{F}_{\mu\nu}(\mathbf{k}))_{n, n}.\]</div>
<p>In the case of a 2-dimensional <em>WFArray</em> array calculates the
Berry curvature over the entire plane.  In higher dimensional case
it will compute flux over all 2-dimensional slices of a
higher-dimensional <em>WFArray</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state_idx</strong> (<em>array_like</em><em>, </em><em>optional</em>) – Optional array of indices of states to be included
in the subsequent calculations, typically the indices of
bands considered occupied. If not specified, or None, all bands are
included.</p></li>
<li><p><strong>plane</strong> (<em>array_like</em><em>, </em><em>optional</em>) – Array or tuple of two indices defining the axes in the
WFArray mesh which the Berry flux is computed over. By default,
all directions are considered, and the full Berry flux tensor is
returned.</p></li>
<li><p><strong>abelian</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – If <em>True</em> then the Berry flux is computed
using the abelian formula, which corresponds to the band-traced
non-Abelian Berry curvature. If <em>False</em> then the non-Abelian Berry
flux tensor is computed. Default value is <em>True</em>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>flux</strong> – The Berry flux tensor, which is an array of general shape
<cite>[dim_mesh, dim_mesh, *flux_shape, n_states, n_states]</cite>. The
shape will depend on the parameters passed to the function.</p>
<p>If plane is <cite>None</cite> (default), then the first two axes
<cite>(dim_mesh, dim_mesh)</cite> correspond to the plane directions, otherwise,
these axes are absent.</p>
<p>If <cite>abelian</cite> is <cite>False</cite> then the last two axes are the band indices
running over the selected <cite>state_idx</cite> indices.
If <cite>abelian</cite> is <cite>True</cite> (default) then the last two axes are absent, and
the returned flux is a scalar value, not a matrix.</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Computes Berry curvature of first three bands in 2D model</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">flux</span> <span class="o">=</span> <span class="n">wf</span><span class="o">.</span><span class="n">berry_flux</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="c1"># shape: (dim1, dim2, nk1, nk2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flux</span> <span class="o">=</span> <span class="n">wf</span><span class="o">.</span><span class="n">berry_flux</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">plane</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c1"># shape: (nk1, nk2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flux</span> <span class="o">=</span> <span class="n">wf</span><span class="o">.</span><span class="n">berry_flux</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">plane</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">abelian</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># shape: (nk1, nk2, n_states, n_states)</span>
</pre></div>
</div>
<p>3D model example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">flux</span> <span class="o">=</span> <span class="n">wf</span><span class="o">.</span><span class="n">berry_flux</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">plane</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c1"># shape: (nk1, nk2, nk3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pythtb.WFArray.chern_num">
<span class="sig-name descname"><span class="pre">chern_num</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plane</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pythtb/wf_array.html#WFArray.chern_num"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pythtb.WFArray.chern_num" title="Link to this definition">#</a></dt>
<dd><p>Computes the Chern number in the specified plane.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.0.0.</span></p>
</div>
<p>The Chern number is computed as the integral of the Berry flux
over the specified plane, divided by <span class="math notranslate nohighlight">\(2 \pi\)</span>.</p>
<div class="math notranslate nohighlight">
\[C = \frac{1}{2\pi} \sum_{\mathbf{k}_{\mu}, \mathbf{k}_{\nu}} F_{\mu\nu}(\mathbf{k}).\]</div>
<p>The plane <span class="math notranslate nohighlight">\((\mu, \nu)\)</span> is specified by <cite>plane</cite>, a tuple of two indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plane</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.13)"><em>tuple</em></a>) – A tuple of two indices specifying the plane in which the Chern number is computed.
The indices should be between 0 and the number of mesh dimensions minus 1.
If None, the Chern number is computed for the first two dimensions of the mesh.</p></li>
<li><p><strong>state_idx</strong> (<em>array-like</em><em>, </em><em>optional array</em>) – Indices of states to be included in the Chern number calculation.
If None, all states are included. None by default.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>chern</strong> – In the two-dimensional case, the result
will be a floating point approximation of the integer Chern number
for that plane. In a higher-dimensional space, the Chern number
is computed for each 2D slice of the higher-dimensional space.
E.g., the shape of the returned array is <cite>(nk3, …, nkd)</cite> if the plane is
<cite>(0, 1)</cite>, where <cite>(nk3, …, nkd)</cite> are the sizes of the mesh in the remaining
dimensions.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray, <a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)">float</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Suppose we have a <cite>WFArray</cite> mesh in three-dimensional space
of shape <cite>(nk1, nk2, nk3)</cite>. We can compute the Chern number for the
<cite>(0, 1)</cite> plane as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wfs</span> <span class="o">=</span> <span class="n">WFArray</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wfs</span><span class="o">.</span><span class="n">solve_on_grid</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chern</span> <span class="o">=</span> <span class="n">wfs</span><span class="o">.</span><span class="n">chern_num</span><span class="p">(</span><span class="n">plane</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">state_idx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_occ</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">chern</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(12,)  # shape of the Chern number array</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "youruser/yourrepo",
            ref: "v2",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./generated"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="pythtb.TBModel.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">pythtb.TBModel</p>
      </div>
    </a>
    <a class="right-next"
       href="pythtb.W90.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">pythtb.W90</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray"><code class="docutils literal notranslate"><span class="pre">WFArray</span></code></a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.__init__"><code class="docutils literal notranslate"><span class="pre">WFArray.__init__()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.wfs"><code class="docutils literal notranslate"><span class="pre">WFArray.wfs</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.shape"><code class="docutils literal notranslate"><span class="pre">WFArray.shape</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.mesh_size"><code class="docutils literal notranslate"><span class="pre">WFArray.mesh_size</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.dim_mesh"><code class="docutils literal notranslate"><span class="pre">WFArray.dim_mesh</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.pbc_axes"><code class="docutils literal notranslate"><span class="pre">WFArray.pbc_axes</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.loop_axes"><code class="docutils literal notranslate"><span class="pre">WFArray.loop_axes</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.nstates"><code class="docutils literal notranslate"><span class="pre">WFArray.nstates</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.nspin"><code class="docutils literal notranslate"><span class="pre">WFArray.nspin</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.norb"><code class="docutils literal notranslate"><span class="pre">WFArray.norb</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.model"><code class="docutils literal notranslate"><span class="pre">WFArray.model</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.param_path"><code class="docutils literal notranslate"><span class="pre">WFArray.param_path</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.flat_k_mesh"><code class="docutils literal notranslate"><span class="pre">WFArray.flat_k_mesh</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.k_mesh"><code class="docutils literal notranslate"><span class="pre">WFArray.k_mesh</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.energies"><code class="docutils literal notranslate"><span class="pre">WFArray.energies</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.get_states"><code class="docutils literal notranslate"><span class="pre">WFArray.get_states()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.get_bloch_states"><code class="docutils literal notranslate"><span class="pre">WFArray.get_bloch_states()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.get_projectors"><code class="docutils literal notranslate"><span class="pre">WFArray.get_projectors()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.solve_k_mesh"><code class="docutils literal notranslate"><span class="pre">WFArray.solve_k_mesh()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.solve_on_path"><code class="docutils literal notranslate"><span class="pre">WFArray.solve_on_path()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.solve_on_grid"><code class="docutils literal notranslate"><span class="pre">WFArray.solve_on_grid()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.solve_on_one_point"><code class="docutils literal notranslate"><span class="pre">WFArray.solve_on_one_point()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.choose_states"><code class="docutils literal notranslate"><span class="pre">WFArray.choose_states()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.empty_like"><code class="docutils literal notranslate"><span class="pre">WFArray.empty_like()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.impose_pbc"><code class="docutils literal notranslate"><span class="pre">WFArray.impose_pbc()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.impose_loop"><code class="docutils literal notranslate"><span class="pre">WFArray.impose_loop()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.position_matrix"><code class="docutils literal notranslate"><span class="pre">WFArray.position_matrix()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.position_expectation"><code class="docutils literal notranslate"><span class="pre">WFArray.position_expectation()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.position_hwf"><code class="docutils literal notranslate"><span class="pre">WFArray.position_hwf()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.get_links"><code class="docutils literal notranslate"><span class="pre">WFArray.get_links()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.wilson_loop"><code class="docutils literal notranslate"><span class="pre">WFArray.wilson_loop()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.berry_loop"><code class="docutils literal notranslate"><span class="pre">WFArray.berry_loop()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.berry_phase"><code class="docutils literal notranslate"><span class="pre">WFArray.berry_phase()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.berry_flux"><code class="docutils literal notranslate"><span class="pre">WFArray.berry_flux()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pythtb.WFArray.chern_num"><code class="docutils literal notranslate"><span class="pre">WFArray.chern_num()</span></code></a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2025, Trey Cole, Sinisa Coh, and David Vanderbilt.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.4.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>